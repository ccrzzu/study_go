package graph

/**
207
现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。
例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]。
给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？
说明:
输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。
你可以假定输入的先决条件中没有重复的边。
提示:
这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。
通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。
拓扑排序也可以通过 BFS 完成。
思路1：Kahn 算法，即拓扑排序。构建的邻接表就是我们通常认识的邻接表，每一个结点存放的是后继结点的集合。

该方法的每一步总是输出当前无前趋（即入度为零）的顶点。为避免每次选入度为  的顶点时扫描整个存储空间，可设置一个队列暂存所有入度为  的顶点。

具体做法如下：

1、在开始排序前，扫描对应的存储空间，将入度为  的顶点均入队列。

2、只要队列非空，就从队首取出入度为  的顶点，将这个顶点输出到结果集中，并且将这个顶点的所有邻接点的入度减 ，在减  以后，发现这个邻接点的入度为  ，就继续入队。

最后检查结果集中的顶点个数是否和课程数相同即可。

思路2：构建逆邻接表，实现深度优先遍历。思路其实也很简单，其实就是检测这个有向图中有没有环，只要存在环，课程就不能完成。

第 1 步：构造逆邻接表；
第 2 步：递归处理每一个还没有被访问的结点；核心思想是：对于一个顶点 vertex 来说，我们先输出了指向它的所有顶点，然后再输出自己，就是这么简单。
第 3 步：如果这个顶点没有被遍历过，就递归遍历它，把所有指向它的结点都输出了，再输出自己。

注意：这个深度优先遍历得通过逆邻接表实现，当访问一个结点的时候，应该递归访问它的前驱结点，直至前驱结点没有前驱结点为止。
**/
func canFinish(n int, pre [][]int) bool {

	return true
}

/**
210
现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
思路：
给出 n 个任务，每两个任务之间有相互依赖关系，比如 A 任务一定要在 B 任务之前完成才行。问是否可以完成所有任务，如果可以完成任务，就输出完成任务的顺序，如果不能完成，输出空数组。
这一题是第 207 题的加强版。解题思路是 AOV 网的拓扑排序。最后输出数组即可。代码和第 207 题基本不变。具体解题思路见第 207 题。
**/
func findOrder(numCourses int, prerequisites [][]int) []int {

	return []int{}
}
